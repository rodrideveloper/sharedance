import 'package:shared_models/shared_models.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class InvitationService {
  final String? baseUrl;
  final String? authToken;
  final Future<String?> Function()? getAuthToken;
  final String Function()? getBaseUrl;

  InvitationService({
    this.baseUrl,
    this.authToken,
    this.getAuthToken,
    this.getBaseUrl,
  });

  String get _currentBaseUrl {
    // If getBaseUrl function is provided, use it to get dynamic baseUrl
    if (getBaseUrl != null) {
      final dynamicUrl = getBaseUrl!();
      print('üîó InvitationService: Using dynamic baseUrl: $dynamicUrl');
      return dynamicUrl;
    }

    // Fallback to static baseUrl
    if (baseUrl != null) {
      print('üîó InvitationService: Using static baseUrl: $baseUrl');
      return baseUrl!;
    }

    throw Exception('No baseUrl provided to InvitationService');
  }

  Future<Map<String, String>> get _headers async {
    final headers = {
      'Content-Type': 'application/json',
    };

    // Usar getAuthToken si est√° disponible, sino usar authToken
    String? token = authToken;
    if (getAuthToken != null) {
      print('üîë InvitationService: Getting token with getAuthToken function');
      token = await getAuthToken!();
      print(
          'üîë InvitationService: Token received: ${token?.substring(0, 20)}...${token?.substring(token.length - 10)}');
    } else {
      print('üîë InvitationService: Using static authToken');
    }

    if (token != null) {
      headers['Authorization'] = 'Bearer $token';
      print('üîë InvitationService: Authorization header set');
    } else {
      print(
          '‚ö†Ô∏è InvitationService: NO TOKEN AVAILABLE - this will cause 401 error');
    }
    return headers;
  }

  // Enviar invitaci√≥n (m√©todo original)
  Future<InvitationResponse> sendInvitation({
    required String email,
    required UserRole role,
    String? customMessage,
  }) async {
    try {
      final roleString = _roleToString(role);
      print('üì§ InvitationService: Sending invitation to: $email');
      print('üì§ InvitationService: Role enum: $role');
      print('üì§ InvitationService: Role string: $roleString');
      print(
          'üîó InvitationService: Using URL: $_currentBaseUrl/api/invitations/send');

      final requestBody = {
        'email': email,
        'role': roleString,
        'customMessage': customMessage ?? '',
      };

      // Debug con alert para ver exactamente qu√© se env√≠a
      print('üö® DEBUG REQUEST BODY: ${jsonEncode(requestBody)}');

      final headers = await _headers;
      print('ÔøΩ DEBUG HEADERS: $headers');

      final response = await http.post(
        Uri.parse('$_currentBaseUrl/api/invitations/send'),
        headers: headers,
        body: jsonEncode(requestBody),
      );

      print('üì§ InvitationService: Response status: ${response.statusCode}');
      print('üì§ InvitationService: Response body: ${response.body}');

      final data = jsonDecode(response.body) as Map<String, dynamic>;

      if (response.statusCode == 201) {
        return InvitationResponse(
          success: true,
          message: data['message'] ?? 'Invitaci√≥n enviada correctamente',
          invitationId: data['invitationId'],
        );
      } else {
        return InvitationResponse(
          success: false,
          message: data['error'] ?? 'Error enviando invitaci√≥n',
          error: data['error'],
        );
      }
    } catch (e) {
      return InvitationResponse(
        success: false,
        message: 'Error de conexi√≥n: $e',
        error: e.toString(),
      );
    }
  }

  /// Transforma los datos del backend al formato esperado por el modelo del frontend
  Map<String, dynamic> _transformInvitationData(
      Map<String, dynamic> backendData) {
    print('üîÑ Input data: $backendData');

    try {
      // Verificar campos obligatorios
      if (backendData['id'] == null ||
          backendData['email'] == null ||
          backendData['role'] == null) {
        print('‚ùå Missing required fields in backend data');
        throw Exception('Missing required fields: id, email, or role');
      }

      // Generar un token √∫nico si no existe
      final token = backendData['token'] ??
          'inv_${backendData['id']}_${DateTime.now().millisecondsSinceEpoch}';

      // Manejar fechas - crear DateTime si no existen
      DateTime createdAt;
      DateTime expiresAt;

      try {
        if (backendData['sentAt'] != null) {
          final sentAtValue = backendData['sentAt'];
          print(
              'üîÑ sentAt raw value: $sentAtValue (${sentAtValue.runtimeType})');
          if (sentAtValue is String) {
            createdAt = DateTime.parse(sentAtValue);
          } else {
            print('‚ö†Ô∏è sentAt is not a String, using current time');
            createdAt = DateTime.now();
          }
        } else if (backendData['createdAt'] != null) {
          final createdAtValue = backendData['createdAt'];
          print(
              'üîÑ createdAt raw value: $createdAtValue (${createdAtValue.runtimeType})');
          if (createdAtValue is String) {
            createdAt = DateTime.parse(createdAtValue);
          } else {
            print('‚ö†Ô∏è createdAt is not a String, using current time');
            createdAt = DateTime.now();
          }
        } else {
          // Si no hay fecha, usar la actual
          print('‚ö†Ô∏è No sentAt or createdAt found, using current time');
          createdAt = DateTime.now();
        }
      } catch (e) {
        print('‚ùå Error parsing createdAt/sentAt: $e, using current time');
        createdAt = DateTime.now();
      }

      try {
        if (backendData['expiresAt'] != null) {
          final expiresAtValue = backendData['expiresAt'];
          print(
              'üîÑ expiresAt raw value: $expiresAtValue (${expiresAtValue.runtimeType})');
          if (expiresAtValue is String) {
            expiresAt = DateTime.parse(expiresAtValue);
          } else {
            print('‚ö†Ô∏è expiresAt is not a String, using default expiration');
            expiresAt = createdAt.add(const Duration(days: 30));
          }
        } else {
          // Si no hay fecha de expiraci√≥n, usar 30 d√≠as desde creaci√≥n
          print('‚ö†Ô∏è No expiresAt found, using 30 days from creation');
          expiresAt = createdAt.add(const Duration(days: 30));
        }
      } catch (e) {
        print('‚ùå Error parsing expiresAt: $e, using 30 days from creation');
        expiresAt = createdAt.add(const Duration(days: 30));
      }

      print('üîÑ Dates - createdAt: $createdAt, expiresAt: $expiresAt');

      // Asegurar que invitedByUserId no sea null
      final invitedByUserId = backendData['inviterId'] ??
          backendData['invitedByUserId'] ??
          'system'; // valor por defecto si no existe

      final result = {
        'invitationId': backendData[
            'id'], // Backend usa 'id', frontend espera 'invitationId'
        'email': backendData['email'],
        'role': backendData['role'],
        'token': token,
        'createdAt': createdAt.toIso8601String(), // Convertir a string ISO
        'expiresAt': expiresAt.toIso8601String(), // Convertir a string ISO
        'isUsed': backendData['status'] ==
            'accepted', // Backend usa 'status', frontend espera 'isUsed'
        'usedByUserId': null, // No disponible en backend actual
        'usedAt': null, // No disponible en backend actual
        'invitedByUserId': invitedByUserId,
        'invitedByName': backendData['inviterName'] ??
            backendData['invitedByName'] ??
            'System',
      };

      print('üîÑ Output data: $result');
      return result;
    } catch (e) {
      print('‚ùå Error in _transformInvitationData: $e');
      print('‚ùå Backend data: $backendData');
      rethrow;
    }
  }

  // Crear instructor autom√°ticamente
  Future<InvitationResponse> createInstructor({
    required String email,
    required String firstName,
    required String lastName,
    required String phone,
  }) async {
    try {
      final response = await http.post(
        Uri.parse('$_currentBaseUrl/api/invitations/create-instructor'),
        headers: await _headers,
        body: jsonEncode({
          'email': email,
          'firstName': firstName,
          'lastName': lastName,
          'phone': phone,
        }),
      );

      final data = jsonDecode(response.body) as Map<String, dynamic>;

      if (response.statusCode == 201) {
        return InvitationResponse(
          success: true,
          message: data['message'] ??
              'Instructor creado y email enviado correctamente',
          invitationId: data['invitationId'],
        );
      } else {
        return InvitationResponse(
          success: false,
          message: data['error'] ?? 'Error creando instructor',
          error: data['error'],
        );
      }
    } catch (e) {
      return InvitationResponse(
        success: false,
        message: 'Error de conexi√≥n: $e',
        error: e.toString(),
      );
    }
  }

  /// Obtiene todas las invitaciones
  Future<List<InvitationModel>> getInvitations() async {
    try {
      final url = '$_currentBaseUrl/api/invitations';
      print('üîó InvitationService: Fetching invitations from: $url');

      final response = await http.get(
        Uri.parse(url),
        headers: await _headers,
      );

      print('üìä InvitationService: Response status: ${response.statusCode}');
      print(
          'üìä InvitationService: Response body preview: ${response.body.substring(0, response.body.length > 200 ? 200 : response.body.length)}...');

      if (response.statusCode == 200) {
        print('üîç Full response body: ${response.body}');
        
        Map<String, dynamic> responseData;
        try {
          responseData = json.decode(response.body);
          print('üîç Decoded response data: $responseData');
        } catch (e) {
          print('‚ùå JSON decode error: $e');
          print('‚ùå Problematic JSON: ${response.body}');
          throw Exception('Failed to parse JSON response: $e');
        }
        
        final List<dynamic> data = responseData['invitations'] ?? [];
        print('üîç Extracted invitations array: $data');
        print('üîç Array length: ${data.length}');

        // Debug cada elemento del array individualmente
        for (int i = 0; i < data.length; i++) {
          print('üîç Element $i type: ${data[i].runtimeType}');
          print('üîç Element $i value: ${data[i]}');
          if (data[i] is Map) {
            final item = data[i] as Map<String, dynamic>;
            print('üîç Element $i keys: ${item.keys.toList()}');
          }
        }

        print(
            '‚úÖ InvitationService: Successfully fetched ${data.length} invitations');

        final List<InvitationModel> invitations = [];
        for (int i = 0; i < data.length; i++) {
          try {
            final rawInvitationData = data[i];
            print(
                'üîç Processing invitation $i: Type: ${rawInvitationData.runtimeType}, Value: $rawInvitationData');

            if (rawInvitationData == null) {
              print('‚ö†Ô∏è Invitation $i is null, skipping...');
              continue;
            }

            // Verificar que es un Map antes de convertir
            if (rawInvitationData is! Map<String, dynamic>) {
              print(
                  '‚ö†Ô∏è Invitation $i is not a Map, got: ${rawInvitationData.runtimeType}');
              continue;
            }

            final rawInvitation = rawInvitationData;
            print('üîÑ Transforming invitation data for invitation $i');
            print('üîç Raw invitation keys: ${rawInvitation.keys.toList()}');

            final transformedData = _transformInvitationData(rawInvitation);
            print('‚ú® Transformed data: $transformedData');

            final invitation = InvitationModel.fromJson(transformedData);
            invitations.add(invitation);
            print('‚úÖ Successfully parsed invitation $i');
          } catch (e, stackTrace) {
            print('‚ùå Error parsing invitation $i: $e');
            print('‚ùå Raw data: ${data[i]}');
            print('‚ùå Stack trace: $stackTrace');
            // Continue with next invitation instead of failing completely
            continue;
          }
        }

        return invitations;
      } else {
        print(
            '‚ùå InvitationService: Failed to fetch invitations - Status: ${response.statusCode}');
        print('‚ùå InvitationService: Response body: ${response.body}');
        throw Exception('Failed to load invitations: ${response.statusCode}');
      }
    } catch (e, stackTrace) {
      print('‚ùå InvitationService: Exception in getInvitations: $e');
      print('‚ùå Stack trace: $stackTrace');
      throw Exception('Error fetching invitations: $e');
    }
  }

  // Cancelar invitaci√≥n
  Future<bool> cancelInvitation(String invitationId) async {
    try {
      final response = await http.delete(
        Uri.parse('$_currentBaseUrl/api/invitations/$invitationId'),
        headers: await _headers,
      );

      return response.statusCode == 200;
    } catch (e) {
      print('Error canceling invitation: $e');
      return false;
    }
  }

  // Reenviar invitaci√≥n
  Future<bool> resendInvitation(String invitationId) async {
    try {
      final response = await http.post(
        Uri.parse('$_currentBaseUrl/api/invitations/$invitationId/resend'),
        headers: await _headers,
      );

      return response.statusCode == 200;
    } catch (e) {
      print('Error resending invitation: $e');
      return false;
    }
  }

  // M√©todo auxiliar para convertir UserRole a String
  String _roleToString(UserRole role) {
    switch (role) {
      case UserRole.admin:
        return 'Admin';
      case UserRole.teacher:
        return 'Teacher'; // May√∫scula para coincidir con backend
      case UserRole.student:
        return 'Student';
    }
  }
}
